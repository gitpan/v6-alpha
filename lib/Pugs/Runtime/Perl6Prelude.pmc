# Generated by v6 0.016 (Module::Compile 0.20) - do not edit!
################((( 32-bit Checksum Validator III )))################
#line 1
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); if (unpack('%32N*',
$F=readline(*F)) != 0x2A358374) { use Filter::Util::Call; my $f = $F;
filter_add(sub { filter_del(); 1 while &filter_read; $_ = $f; 1; })}}
#line 1
package main;
use Config;
use lib split(/\Q$Config{path_sep}/, $ENV{PERL6LIB} || '');
use Scalar::Util;
         use Pugs::Runtime::Perl6;
         use Pugs::Runtime::Perl6Prelude;
         use Pugs::Runtime::Perl5Container;
         use base 'Pugs::Grammar::Base';  
         use strict;
         no strict 'refs';
         no warnings ('void', 'uninitialized');
         $::_V6_COMPILER_OS      = 'darwin';
         $::_V6_COMPILER_NAME    = 'v6.pm';
         $::_V6_COMPILER_VERSION = '0.016';
         undef $::_V6_MATCH_;
         my %_V6_PAD;
         our %_V6_STATE;
         # use v6-alpha
;
{ package Str;
                        use Moose; 
                        Pugs::Runtime::Perl6->setup_class;
                        no strict 'refs';
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ; };
{ package Bool;
                        use Moose; 
                        Pugs::Runtime::Perl6->setup_class;
                        no strict 'refs';
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ;  {  sub False {
   my %_V6_PAD;
0;

 };
## Signature for False
 Data::Bind->sub_signature
 (\&False, );
;
 sub True {
   my %_V6_PAD;
1;

 };
## Signature for True
 Data::Bind->sub_signature
 (\&True, );
;
 } };
package main;
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ;
do { { package bool; require Exporter;  our @ISA = qw(Exporter); our @EXPORT = ('False','True');  sub False { 0 } 
 sub True { 1 } } bool->import(); 1 } ;
push @EXPORT, 'true'; sub true {
   my %_V6_PAD;
$_->[0] ?  bool::True() :  bool::False();

 };
## Signature for true
 Data::Bind->sub_signature
 (\&true, );
;
push @EXPORT, 'Inf'; sub Inf {
   my %_V6_PAD;
 Pugs::Runtime::Perl6::Inf();

 };
## Signature for Inf
 Data::Bind->sub_signature
 (\&Inf, );
;
push @EXPORT, 'NaN'; sub NaN {
   my %_V6_PAD;
 Pugs::Runtime::Perl6::NaN();

 };
## Signature for NaN
 Data::Bind->sub_signature
 (\&NaN, );
;
 sub slurp {
   my %_V6_PAD;
( die "not implemented" );

 };
## Signature for slurp
 Data::Bind->sub_signature
 (\&slurp, );
;
package Perl6::Internals;
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ;
 sub compile_pir {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for compile_pir
 Data::Bind->sub_signature
 (\&compile_pir, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
push @EXPORT, 'exit'; sub exit {
   my %_V6_PAD;
  my ($status);
  Data::Bind->arg_bind(\@_);
  ;
 CORE::exit($status);;

 };
## Signature for exit
 Data::Bind->sub_signature
 (\&exit, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$status'});
;
push @EXPORT, 'sleep'; sub sleep {
   my %_V6_PAD;
  my ($seconds);
  Data::Bind->arg_bind(\@_);
  ;
 CORE::sleep($seconds);;

 };
## Signature for sleep
 Data::Bind->sub_signature
 (\&sleep, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$seconds'});
;
 sub open {
   my %_V6_PAD;
  my ($file);
  Data::Bind->arg_bind(\@_);
  ;
 my $fh = IO::File->new; $fh->open($file); $fh;;

 };
## Signature for open
 Data::Bind->sub_signature
 (\&open, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$file'});
;
package Pugs::Internals;
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ;
 sub compile_file_to_yml {
   my %_V6_PAD;
  my ($path);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for compile_file_to_yml
 Data::Bind->sub_signature
 (\&compile_file_to_yml, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$path'});
;
 sub install_pragma_value {
   my %_V6_PAD;
  my ($class,$value);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for install_pragma_value
 Data::Bind->sub_signature
 (\&install_pragma_value, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Class',  'var' => '$class'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$value'});
;
 sub current_pragma_value {
   my %_V6_PAD;
  my ($class);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for current_pragma_value
 Data::Bind->sub_signature
 (\&current_pragma_value, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Class',  'var' => '$class'});
;
 sub eval_perl6 {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for eval_perl6
 Data::Bind->sub_signature
 (\&eval_perl6, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
 sub eval_haskell {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for eval_haskell
 Data::Bind->sub_signature
 (\&eval_haskell, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
 sub eval_parrot {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for eval_parrot
 Data::Bind->sub_signature
 (\&eval_parrot, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
 sub eval_perl5 {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for eval_perl5
 Data::Bind->sub_signature
 (\&eval_perl5, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
 sub eval_yaml {
   my %_V6_PAD;
  my ($code);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for eval_yaml
 Data::Bind->sub_signature
 (\&eval_yaml, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$code'});
;
 sub exec {
   my %_V6_PAD;
  my ($prog,$flag,@args);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for exec
 Data::Bind->sub_signature
 (\&exec, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$prog'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Bool',  'var' => '$flag'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '@args'});
;
 sub hSeek {
   my %_V6_PAD;
  my ($file,$position,$whence);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for hSeek
 Data::Bind->sub_signature
 (\&hSeek, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'File',  'var' => '$file'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Int',  'var' => '$position'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Int',  'var' => '$whence'});
;
 sub hSetBinaryMode {
   my %_V6_PAD;
  my ($fh,$binary);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for hSetBinaryMode
 Data::Bind->sub_signature
 (\&hSetBinaryMode, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$fh'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Bool',  'var' => '$binary'});
;
 sub localtime {
   my %_V6_PAD;
  my ($want_item,$sec,$pico);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for localtime
 Data::Bind->sub_signature
 (\&localtime, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => 'Bool',  'var' => '$want_item'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$sec'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$pico'});
;
 sub openFile {
   my %_V6_PAD;
  my ($filename,$mode);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for openFile
 Data::Bind->sub_signature
 (\&openFile, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$filename'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$mode'});
;
 sub require {
   my %_V6_PAD;
  my ($module);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for require
 Data::Bind->sub_signature
 (\&require, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$module'});
;
 sub require_use_helper {
   my %_V6_PAD;
  my ($is_use,$module);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for require_use_helper
 Data::Bind->sub_signature
 (\&require_use_helper, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Bool',  'var' => '$is_use'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$module'});
;
 sub runInteractiveCommand {
   my %_V6_PAD;
  my ($command);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for runInteractiveCommand
 Data::Bind->sub_signature
 (\&runInteractiveCommand, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$command'});
;
 sub sprintf {
   my %_V6_PAD;
  my ($conversion,@arg);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for sprintf
 Data::Bind->sub_signature
 (\&sprintf, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$conversion'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '@arg'});
;
 sub use {
   my %_V6_PAD;
  my ($module);
  Data::Bind->arg_bind(\@_);
  ;
( die "not implemented" );

 };
## Signature for use
 Data::Bind->sub_signature
 (\&use, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$module'});
;
use Pugs::Runtime::Perl6AST ;

; 1;
