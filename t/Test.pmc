# Generated by v6 0.014 (Module::Compile 0.18) - do not edit!
################((( 32-bit Checksum Validator III )))################
#line 1
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); if (unpack('%32N*',
$F=readline(*F)) != 0xD8A74418) { use Filter::Util::Call; my $f = $F;
filter_add(sub { filter_del(); 1 while &filter_read; $_ = $f; 1; })}}
#line 1
package main;
use Config;
use lib split( /\Q$Config{path_sep}/, $ENV{PERL6LIB} || '' );
use Scalar::Util;
use Pugs::Runtime::Perl6;
use Pugs::Runtime::Perl6Prelude;
use strict;
no strict 'refs';
no warnings( 'void', 'uninitialized' );
$::_V6_COMPILER_OS      = 'linux';
$::_V6_COMPILER_NAME    = 'v6.pm';
$::_V6_COMPILER_VERSION = '0.014';
my %_V6_PAD;
our %_V6_STATE;

# use v6-alpha
package Test;
$Test::VERSION = '0.0.6';
use Exporter 'import';
push our @ISA, 'Exporter';
our @EXPORT;
bool->import();    # True, False
$Test::ALWAYS_CALLER        = @::ENV{qw(TEST_ALWAYS_CALLER)};
$Test::num_of_tests_run     = 0;
$Test::num_of_tests_failed  = 0;
$Test::num_of_tests_badpass = 0;
$Test::num_of_tests_planned;
$Test::todo_next_test           = False();
$Test::force_todo_test_junction = '';
$Test::testing_started          = 1;
push @EXPORT, 'plan';

sub plan {
  my %_V6_PAD;
  my ($number_of_tests);
  Data::Bind->arg_bind( \@_ );
  $Test::testing_started      = 1;
  $Test::num_of_tests_planned = $number_of_tests;
  ( print '', ("1..$number_of_tests"), "\n" );

}
## Signature for plan
Data::Bind->sub_signature( \&plan, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Int', 'var' => '$number_of_tests' } );
push @EXPORT, 'force_todo';

sub force_todo {
  my %_V6_PAD;
  my (@todo_tests);
  Data::Bind->arg_bind( \@_ );
  $Test::force_todo_test_junction = join( ' ', '', @todo_tests, '' );

}
## Signature for force_todo
Data::Bind->sub_signature( \&force_todo, { 'attribute' => [], 'is_slurpy' => '*', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '@todo_tests' } );
push @EXPORT, 'ok';

sub ok {
  my %_V6_PAD;
  my ( $cond, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Test::proclaim( [ \( $cond, $desc, $todo, ) ], { depends => \($depends) } );

}
## Signature for ok
Data::Bind->sub_signature( \&ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Bool', 'var' => '$cond' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'is';

sub is {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $test ), scalar \( $got eq $expected ) );
  Test::proclaim( [ \( $test, $desc, $todo, $got, $expected, $depends, ) ], {} );

}
## Signature for is
Data::Bind->sub_signature( \&is, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'is_deeply';

sub is_deeply {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  my $got_perl      = Pugs::Runtime::Perl6::perl($got);
  my $expected_perl = Pugs::Runtime::Perl6::perl($expected);
  Data::Bind::bind_op2( \( my $test ), scalar \( $got_perl eq $expected_perl ) );
  Test::proclaim( [ \( $test, $desc, $todo, $got_perl, $expected_perl, $depends, ) ], {} );

}
## Signature for is_deeply
Data::Bind->sub_signature( \&is_deeply, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Any', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Any', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'isnt';

sub isnt {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $test ), scalar \( not( $got eq $expected ) ) );
  Test::proclaim( [ \( $test, "Should not match: $desc", $todo, $got, $expected, $depends, ) ], { negate => \(1) } );

}
## Signature for isnt
Data::Bind->sub_signature( \&isnt, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'like';

sub like {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $test ), scalar \( $got =~ ( ref($expected) eq "Regexp" ? $expected : quotemeta($expected) ) ) );
  Test::proclaim( [ \( $test, $desc, $todo, $got, $expected, $depends, ) ], {} );

}
## Signature for like
Data::Bind->sub_signature( \&like, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Rule', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'unlike';

sub unlike {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $test ), scalar \( not( $got =~ ( ref($expected) eq "Regexp" ? $expected : quotemeta($expected) ) ) ) );
  Test::proclaim( [ \( $test, $desc, $todo, $got, $expected, $depends, ) ], { negate => \(1) } );

}
## Signature for unlike
Data::Bind->sub_signature( \&unlike, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Rule', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'eval_ok';

sub eval_ok {
  my %_V6_PAD;
  my ( $code, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $result ), scalar \( Pugs::Runtime::Perl6::eval( [ \( $code, ) ], {} ) ) );
  if ( length($@) ) {
    Test::proclaim( [ \( undef, $desc, $todo, "eval was fatal: $!", ) ], { depends => \($depends) } );
  }
  else {
    @_ = ( [ \( $result, $desc, ) ], { todo => \($todo), depends => \($depends) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::ok )->code );
  }

}
## Signature for eval_ok
Data::Bind->sub_signature( \&eval_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$code' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'eval_is';

sub eval_is {
  my %_V6_PAD;
  my ( $code, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $result ), scalar \( Pugs::Runtime::Perl6::eval( [ \( $code, ) ], {} ) ) );
  if ( length($@) ) {
    Test::proclaim( [ \( undef, $desc, $todo, "eval was fatal: $!", $expected, $depends, ) ], {} );
  }
  else {
    @_ = ( [ \( $result, $expected, $desc, ) ], { todo => \($todo), depends => \($depends) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::is )->code );
  }

}
## Signature for eval_is
Data::Bind->sub_signature( \&eval_is, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$code' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'cmp_ok';

sub cmp_ok {
  my %_V6_PAD;
  my ( $got, $expected, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $test ), scalar \( compare_func( [ \( $got, $expected, ) ], {} ) ) );
  Test::proclaim( [ \( $test, $desc, $todo, $got, "&compare_func.name() $expected", $depends, ) ], {} );

}
## Signature for cmp_ok
Data::Bind->sub_signature( \&cmp_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Code', 'var' => '&compare_func' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'isa_ok';

sub isa_ok {
  my %_V6_PAD;
  my ( $ref, $expected_type, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Data::Bind::bind_op2( \( my $out ), scalar \( ( defined($desc) ) ? $desc : "The object is-a '$expected_type'" ) );
  Data::Bind::bind_op2(
    \( my $test ),
    scalar \(
      do { my @_V6_TMP = $ref; ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0] ? $_V6_TMP[0]->isa($expected_type) : Pugs::Runtime::Perl6::Scalar::isa( @_V6_TMP, ($expected_type) ) ) }
    )
  );
  Test::proclaim( [ \( $test, $out, $todo, ref($ref), $expected_type, $depends, ) ], {} );

}
## Signature for isa_ok
Data::Bind->sub_signature( \&isa_ok, { 'attribute' => [ [ { 'bareword' => 'is' }, { 'bareword' => 'rw' } ] ], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => { 'exp1' => 'Any', 'exp2' => { 'exp1' => 'Junction', 'exp2' => 'Pair', 'op1' => '|' }, 'op1' => '|' }, 'var' => '$ref' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$expected_type' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'use_ok';

sub use_ok {
  my %_V6_PAD;
  my ( $module, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  my $caller = do { my @_V6_TMP = Pugs::Runtime::Perl6::Routine->new( Devel::Caller::caller_cv(1) ); ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0] ? $_V6_TMP[0]->package() : Pugs::Runtime::Perl6::Scalar::package( @_V6_TMP, ) ) };
  Pugs::Runtime::Perl6::eval( [ \( "package $caller; require $module", ) ], {} );
  if ($::_V6_ERR_) {
    Test::proclaim( [ \( undef, "require $module;", $todo, "Import error when loading $module: $!", ) ], { depends => \($depends) } );
  }
  else {
    @_ = ( [ \( 1, "$module imported OK", ) ], { todo => \($todo), depends => \($depends) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::ok )->code );
  }

}
## Signature for use_ok
Data::Bind->sub_signature( \&use_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$module' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'throws_ok';

sub throws_ok {
  my %_V6_PAD;
  my ( $match, $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  do {
    $_V6_PAD{6346} = [ eval { code(); } ];
    $::_V6_ERR_ = $@;
    @{ $_V6_PAD{6346} };
  };
  if ($::_V6_ERR_) {
    @_ = ( [ \( $::_V6_ERR_ =~ ( ref($match) eq "Regexp" ? $match : quotemeta($match) ), $desc, ) ], { todo => \($todo), depends => \($depends) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::ok )->code );
  }
  else {
    Test::proclaim( [ \( undef, $desc, $todo, "No exception thrown", ) ], { depends => \($depends) } );
  }

}
## Signature for throws_ok
Data::Bind->sub_signature( \&throws_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Code', 'var' => '&code' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Any', 'var' => '$match' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'dies_ok';

sub dies_ok {
  my %_V6_PAD;
  my ( $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  do {
    $_V6_PAD{6347} = [ eval { code(); } ];
    $::_V6_ERR_ = $@;
    @{ $_V6_PAD{6347} };
  };
  if ($::_V6_ERR_) {
    @_ = ( [ \( 1, $desc, ) ], { todo => \($todo) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::ok )->code );
  }
  else {
    Test::proclaim( [ \( undef, $desc, $todo, "No exception thrown", ) ], { depends => \($depends) } );
  }

}
## Signature for dies_ok
Data::Bind->sub_signature( \&dies_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Code', 'var' => '&code' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'lives_ok';

sub lives_ok {
  my %_V6_PAD;
  my ( $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  do {
    $_V6_PAD{6348} = [ eval { code(); } ];
    $::_V6_ERR_ = $@;
    @{ $_V6_PAD{6348} };
  };
  if ($::_V6_ERR_) {
    Test::proclaim( [ \( undef, $desc, $todo, "An exception was thrown : $!", ) ], { depends => \($depends) } );
  }
  else {
    @_ = ( [ \( 1, $desc, ) ], { todo => \($todo), depends => \($depends) } );
    goto( Pugs::Runtime::Perl6::Routine->new( \&Test::ok )->code );
  }

}
## Signature for lives_ok
Data::Bind->sub_signature( \&lives_ok, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Code', 'var' => '&code' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );

sub version_lt {
  my %_V6_PAD;
  my ( $version1, $version2 );
  Data::Bind->arg_bind( \@_ );
  my @num1 = split( '.', $version1 );
  my @num2 = split( '.', $version2 );
  Pugs::Runtime::Perl6::Array::map(
    [
      \Data::Bind->sub_signature(
        sub {
          my %_V6_PAD;
          my ( $a, $b );
          Data::Bind->arg_bind( \@_ );
          if ( $a == $b ) { next() }
          if ( $a < $b )  { return ( True() ) }
          return ( False() );

        },
        { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '$a' },
        { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '$b' }
      ),
      [
        do {
          my $n = @num1 > @num2 ? @num1 : @num2;
          map { ( $num1[$_], $num2[$_] ) } 0 .. $n - 1;
          }
      ]
    ],
    {}
  );
  return ( False() );

}
## Signature for version_lt
Data::Bind->sub_signature( \&version_lt, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$version1' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$version2' } );
push @EXPORT, 'todo';

sub todo {
  my %_V6_PAD;
  my (%deadline);
  Data::Bind->arg_bind( \@_ );
  if ( ( defined $::_V6_COMPILER_NAME ) ? 0 : 1 ) { return () }
  my $spec_ver = $deadline{ lc($::_V6_COMPILER_NAME) };
  if ( ( ( ( defined $spec_ver ) ? 0 : 1 or $spec_ver eq '1' ) or Test::version_lt( [ \( $::_V6_COMPILER_VERSION, $spec_ver, ) ], {} ) ) ) {
    $Test::todo_next_test = True();
    return ( True() );
  }
  return ( False() );

}
## Signature for todo
Data::Bind->sub_signature( \&todo, { 'attribute' => [], 'is_slurpy' => '*', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '%deadline' } );
push @EXPORT, 'skip';

sub skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5 {
  my %_V6_PAD;
  my ( $reason, $depends );
  Data::Bind->arg_bind( \@_ );
  Test::proclaim( [ \( 1, "", "skip $reason", ) ], { depends => \($depends) } );

}
## Signature for skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5
Data::Bind->sub_signature( \&skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$reason' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
BEGIN { Sub::Multi->add_multi( 'skip', \&skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5 ) }
push @EXPORT, 'skip';

sub skip_63cca366074e191396ec328f2456877c {
  my %_V6_PAD;
  my ( $count, $reason, $depends );
  Data::Bind->arg_bind( \@_ );
  for ( ( 1 .. $count ) ) {
    if ( $^O eq "browser" ) {
      Test::proclaim( [ \( 1, "", "skip $reason", ) ], { depends => \($depends) } );
    }
    else {
      Test::skip( [ \( $reason, ) ], { depends => \($depends) } );
    }
  }

}
## Signature for skip_63cca366074e191396ec328f2456877c
Data::Bind->sub_signature( \&skip_63cca366074e191396ec328f2456877c, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Int', 'var' => '$count' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$reason' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
BEGIN { Sub::Multi->add_multi( 'skip', \&skip_63cca366074e191396ec328f2456877c ) }
push @EXPORT, 'skip_rest';

sub skip_rest {
  my %_V6_PAD;
  my ( $reason, $depends );
  Data::Bind->arg_bind( \@_ );
  Test::skip( [ \( ( $Test::num_of_tests_planned - $Test::num_of_tests_run ), ( !defined( $_V6_PAD{6349} = ($reason) ) ? ("") : $_V6_PAD{6349} ), ) ], { depends => \($depends) } );

}
## Signature for skip_rest
Data::Bind->sub_signature( \&skip_rest, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$reason' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'pass';

sub pass {
  my %_V6_PAD;
  my ($desc);
  Data::Bind->arg_bind( \@_ );
  Test::proclaim( [ \( 1, $desc, ) ], {} );

}
## Signature for pass
Data::Bind->sub_signature( \&pass, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' } );
push @EXPORT, 'flunk';

sub flunk {
  my %_V6_PAD;
  my ( $desc, $todo, $depends );
  Data::Bind->arg_bind( \@_ );
  Test::proclaim( [ \( 0, $desc, $todo, ) ], { depends => \($depends) } );

}
## Signature for flunk
Data::Bind->sub_signature( \&flunk, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => ':', 'optional' => '', 'type' => undef, 'var' => '$depends' } );
push @EXPORT, 'diag';

sub diag {
  my %_V6_PAD;
  my ($diag);
  Data::Bind->arg_bind( \@_ );
  for my $line ( split( "\n", $diag ) ) {
    if ( $::_V6_MATCH_ = Pugs::Compiler::Regex->compile(q{Failed \(TODO.*?\) test})->match($diag) ) {
      print '', $::_V6_STDOUT, "\n";
    }
    else {
      print STDERR '', ("# $line"), "\n";
    }
  }

}
## Signature for diag
Data::Bind->sub_signature( \&diag, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Str', 'var' => '$diag' } );

sub proclaim {
  my %_V6_PAD;
  my ( $cond, $desc, $todo, $got, $expected, $depends, $negate );
  Data::Bind->arg_bind( \@_ );
  $Test::testing_started = 1;
  $Test::num_of_tests_run++;
  my $context;
  if ( index( $Test::force_todo_test_junction, ' ' . $Test::num_of_tests_run . ' ' ) >= 0 ) { $context = "TODO for release" }
  if ($Test::todo_next_test) {
    $context = "TODO" . (
      do { my @_V6_TMP = $todo; ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0] ? $_V6_TMP[0]->isa('Str') : Pugs::Runtime::Perl6::Scalar::isa( @_V6_TMP, ('Str') ) ) }
      ? " $todo" : ''
    );
    $Test::todo_next_test = False();
  }
  else { $todo }
  if ($depends) {
    $context .= " (depends on $depends working)";
  }
  my $out = ( defined $desc ) ? " - $desc" : "";
  if ($Test::ALWAYS_CALLER) {
    $out = "$out <pos:" . do {
      join( ' line ', ( caller(1) )[ 1, 2 ] );
      }
      . ">";
  }
  $out =~ s{#}{\\#}g;
  my $context_out = ( defined $context ) ? " # $context" : "";
  unless ($cond) { print '', "not " }
  ( print '', ( "ok ", $Test::num_of_tests_run, $out, $context_out ), "\n" );
  unless ($cond) { Test::report_failure( [ \( $context, $got, $expected, $negate, ) ], {} ) }
  return ($cond);

}
## Signature for proclaim
Data::Bind->sub_signature( \&proclaim, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => 'Bool', 'var' => '$cond' }, { 'attribute' => [ [ { 'bareword' => 'is' }, { 'bareword' => 'copy' } ] ], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$desc' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => undef, 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => undef, 'var' => '$depends' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => undef, 'var' => '$negate' } );

sub report_failure {
  my %_V6_PAD;
  my ( $todo, $got, $expected, $negate );
  Data::Bind->arg_bind( \@_ );
  if ($todo) {
    Test::diag(
      [
        \(
          "  Failed ($todo) test (" . do {
            join( ' line ', ( caller(2) )[ 1, 2 ] );
            }
            . ")",
        )
      ],
      {}
    );
  }
  else {
    Test::diag(
      [
        \(
          "  Failed test (" . do {
            join( ' line ', ( caller(2) )[ 1, 2 ] );
            }
            . ")",
        )
      ],
      {}
    );
    $Test::num_of_tests_failed++;
  }
  my $wanted = $negate ? "Unwanted" : "Expected";
  if ( index( '&Test::is &Test::isnt &Test::cmp_ok &Test::eval_is &Test::isa_ok &Test::is_deeply &Test::todo_is &Test::todo_isnt &Test::todo_cmp_ok &Test::todo_eval_is &Test::todo_isa_ok ', Pugs::Runtime::Perl6::Routine->new( Devel::Caller::caller_cv(2) )->name() . ' ' ) >= 0 ) {
    Test::diag( [ \( "  $wanted: '" .  ( ( defined $expected ) ? $expected : "undef" ) . "'", ) ], {} );
    Test::diag( [ \( "    Actual: '" . ( ( defined $got )      ? $got      : "undef" ) . "'", ) ], {} );
  }
  else {
    Test::diag( [ \( "    Actual: " . ( ( defined $got ) ? $got : "undef" ), ) ], {} );
  }

}
## Signature for report_failure
Data::Bind->sub_signature( \&report_failure, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$todo' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$got' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Str', 'var' => '$expected' }, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '?', 'type' => 'Bool', 'var' => '$negate' } );

sub test_ends {
  my %_V6_PAD;
  unless ($Test::testing_started) { return () }
  if ( ( defined($Test::num_of_tests_planned) ) ? 0 : 1 ) {
    ( print '', ("1..$Test::num_of_tests_run"), "\n" );
  }
  else { ( $Test::num_of_tests_planned != $Test::num_of_tests_run ) }
  if ($Test::num_of_tests_failed) {
    print STDERR '', ("# Looks like you failed $Test::num_of_tests_failed tests of $Test::num_of_tests_run"), "\n";
  }
  if ($Test::num_of_tests_badpass) {
    print STDERR '', ("# Looks like $Test::num_of_tests_badpass tests of $Test::num_of_tests_run passed unexpectedly"), "\n";
  }
  $Test::num_of_tests_run         = 0;
  $Test::num_of_tests_failed      = 0;
  $Test::num_of_tests_badpass     = 0;
  $Test::num_of_tests_planned     = undef;
  $Test::force_todo_test_junction = undef;
  $Test::testing_started          = 0;

}
## Signature for test_ends
Data::Bind->sub_signature( \&test_ends, );

END {
  Test::test_ends();
}

1;
