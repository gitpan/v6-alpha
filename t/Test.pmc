# Generated by v6 0.015 (Module::Compile 0.20) - do not edit!
################((( 32-bit Checksum Validator III )))################
#line 1
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); if (unpack('%32N*',
$F=readline(*F)) != 0x2687B7D0) { use Filter::Util::Call; my $f = $F;
filter_add(sub { filter_del(); 1 while &filter_read; $_ = $f; 1; })}}
#line 1
package main;
use Config;
use lib split(/\Q$Config{path_sep}/, $ENV{PERL6LIB} || '');
use Scalar::Util;
         use Pugs::Runtime::Perl6;
         use Pugs::Runtime::Perl6Prelude;
         use Pugs::Runtime::Perl5Container;
         use base 'Pugs::Grammar::Base';  
         use strict;
         no strict 'refs';
         no warnings ('void', 'uninitialized');
         $::_V6_COMPILER_OS      = 'darwin';
         $::_V6_COMPILER_NAME    = 'v6.pm';
         $::_V6_COMPILER_VERSION = '0.015';
         undef $::_V6_MATCH_;
         my %_V6_PAD;
         our %_V6_STATE;
         # use v6-alpha
;
package Test;
                        $Test::VERSION = '0.0.7';
                use Exporter 'import'; 
                push our @ISA, 'Exporter';
                our @EXPORT; 
                bool->import();  # True, False
                 ;
$Test::ALWAYS_CALLER = $::ENV{ 'TEST_ALWAYS_CALLER' };
$Test::num_of_tests_run = 0;
$Test::num_of_tests_failed = 0;
$Test::num_of_tests_badpass = 0;
$Test::num_of_tests_planned;
$Test::todo_next_test =  False();
$Test::force_todo_test_junction = '';
$Test::testing_started = 1;
push @EXPORT, 'plan'; sub plan {
   my %_V6_PAD;
  my ($number_of_tests);
  Data::Bind->arg_bind(\@_);
  ;
$Test::testing_started = 1;
$Test::num_of_tests_planned = $number_of_tests;
 ( print '', ("1.." . $number_of_tests),"\n" ) ;

 };
## Signature for plan
 Data::Bind->sub_signature
 (\&plan, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Int',  'var' => '$number_of_tests'});
;
push @EXPORT, 'force_todo'; sub force_todo {
   my %_V6_PAD;
  my (@todo_tests);
  Data::Bind->arg_bind(\@_);
  ;
$Test::force_todo_test_junction = join(' ',
'',
@todo_tests,
'');

 };
## Signature for force_todo
 Data::Bind->sub_signature
 (\&force_todo, {  'attribute' => [],  'is_slurpy' => '*',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '@todo_tests'});
;
push @EXPORT, 'ok'; sub ok {
   my %_V6_PAD;
  my ($cond,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Test::proclaim([\($cond, $desc, $todo, )], {depends => \($depends)});

 };
## Signature for ok
 Data::Bind->sub_signature
 (\&ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Bool',  'var' => '$cond'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'is'; sub is {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $test),scalar \($got eq $expected) );
 Test::proclaim([\($test, $desc, $todo, $got, $expected, $depends, )], {});

 };
## Signature for is
 Data::Bind->sub_signature
 (\&is, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'is_deeply'; sub is_deeply {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
my $got_perl = ( Pugs::Runtime::Perl6::perl($got) );
my $expected_perl = ( Pugs::Runtime::Perl6::perl($expected) );
 Data::Bind::bind_op2( \(my $test),scalar \($got_perl eq $expected_perl) );
 Test::proclaim([\($test, $desc, $todo, $got_perl, $expected_perl, $depends, )], {});

 };
## Signature for is_deeply
 Data::Bind->sub_signature
 (\&is_deeply, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Any',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Any',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'isnt'; sub isnt {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $test),scalar \(not ($got eq $expected)) );
 Test::proclaim([\($test, "Should not match: " . $desc, $todo, $got, $expected, $depends, )], {negate => \(1)});

 };
## Signature for isnt
 Data::Bind->sub_signature
 (\&isnt, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'like'; sub like {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $test),scalar \($got =~ (ref($expected) eq "Regexp"  ? $expected : quotemeta($expected))) );
 Test::proclaim([\($test, $desc, $todo, $got, $expected, $depends, )], {});

 };
## Signature for like
 Data::Bind->sub_signature
 (\&like, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Rule',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'unlike'; sub unlike {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $test),scalar \(not ($got =~ (ref($expected) eq "Regexp"  ? $expected : quotemeta($expected)))) );
 Test::proclaim([\($test, $desc, $todo, $got, $expected, $depends, )], {negate => \(1)});

 };
## Signature for unlike
 Data::Bind->sub_signature
 (\&unlike, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Rule',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'eval_dies_ok'; sub eval_dies_ok {
   my %_V6_PAD;
  my ($code,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
sub {
                my $_eval_string = Pugs::Runtime::Perl6::eval_preprocess([\($code, )], {});
                local $@;
                no warnings;
                my @result;
                if (wantarray) {
                    @result = eval $_eval_string;
                }
                else {
                    $result[0] = eval $_eval_string;
                }
                $::_V6_ERR_ = $@;
                #warn $::_V6_ERR_ if $::_V6_ERR_;
                wantarray ? @result : $result[0];
}->();
if( length($@) ) {  @_ = ([\(1, $desc, )], {todo => \($todo)});
 goto( Pugs::Runtime::Perl6::Routine->new(\&Test::ok)->code );
 } 
else  {  Test::proclaim([\( undef , $desc, $todo, "No exception thrown", )], {depends => \($depends)});
 } 
;

 };
## Signature for eval_dies_ok
 Data::Bind->sub_signature
 (\&eval_dies_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$code'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'cmp_ok'; sub cmp_ok {
   my %_V6_PAD;
  my ($got,$expected,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $test),scalar \( compare_func([\($got, $expected, )], {})) );
 Test::proclaim([\($test, $desc, $todo, $got, Pugs::Runtime::Perl6::Routine->new(\&compare_func) . ".name() " . $expected, $depends, )], {});

 };
## Signature for cmp_ok
 Data::Bind->sub_signature
 (\&cmp_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Code',  'var' => '&compare_func'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'isa_ok'; sub isa_ok {
   my %_V6_PAD;
  my ($ref,$expected_type,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Data::Bind::bind_op2( \(my $out),scalar \( (defined ($desc) ) ? $desc : "The object is-a '" . $expected_type . "'") );
 Data::Bind::bind_op2( \(my $test),scalar \(do { my @_V6_TMP = $ref; ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0]  ? $_V6_TMP[0]->isa($expected_type) :  Pugs::Runtime::Perl6::Scalar::isa( @_V6_TMP, ($expected_type)) ) }) );
 Test::proclaim([\($test, $out, $todo, ref($ref), $expected_type, $depends, )], {});

 };
## Signature for isa_ok
 Data::Bind->sub_signature
 (\&isa_ok, {  'attribute' => [    [      {        'bareword' => 'is'      },      {        'bareword' => 'rw'      }    ]  ],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => {    'exp1' => 'Any',    'exp2' => {      'exp1' => 'Junction',      'exp2' => 'Pair',      'op1' => '|'    },    'op1' => '|'  },  'var' => '$ref'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$expected_type'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'use_ok'; sub use_ok {
   my %_V6_PAD;
  my ($module,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
my $caller = ( do { my @_V6_TMP = Pugs::Runtime::Perl6::Routine->new(Devel::Caller::caller_cv(1)); ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0]  ? $_V6_TMP[0]->package() :  Pugs::Runtime::Perl6::Scalar::package( @_V6_TMP, ) ) } );
sub {
                my $_eval_string = Pugs::Runtime::Perl6::eval_preprocess([\("package " . $caller . "; require " . $module, )], {});
                local $@;
                no warnings;
                my @result;
                if (wantarray) {
                    @result = eval $_eval_string;
                }
                else {
                    $result[0] = eval $_eval_string;
                }
                $::_V6_ERR_ = $@;
                #warn $::_V6_ERR_ if $::_V6_ERR_;
                wantarray ? @result : $result[0];
}->();
if($::_V6_ERR_) {  Test::proclaim([\( undef , "require " . $module . ";", $todo, "Import error when loading " . $module . ": " . $::_V6_ERR_, )], {depends => \($depends)});
 } 
else  {  @_ = ([\(1, $module . " imported OK", )], {todo => \($todo),depends => \($depends)});
 goto( Pugs::Runtime::Perl6::Routine->new(\&Test::ok)->code );
 } 
;

 };
## Signature for use_ok
 Data::Bind->sub_signature
 (\&use_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$module'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'throws_ok'; sub throws_ok {
   my %_V6_PAD;
  my ($match,$desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
do { $_V6_PAD{5963} = [ eval  {  code();
 }  ]; $::_V6_ERR_ = $@; @{$_V6_PAD{5963}} };
if($::_V6_ERR_) {  @_ = ([\($::_V6_ERR_ =~ (ref($match) eq "Regexp"  ? $match : quotemeta($match)), $desc, )], {todo => \($todo),depends => \($depends)});
 goto( Pugs::Runtime::Perl6::Routine->new(\&Test::ok)->code );
 } 
else  {  Test::proclaim([\( undef , $desc, $todo, "No exception thrown", )], {depends => \($depends)});
 } 
;

 };
## Signature for throws_ok
 Data::Bind->sub_signature
 (\&throws_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Code',  'var' => '&code'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Any',  'var' => '$match'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'dies_ok'; sub dies_ok {
   my %_V6_PAD;
  my ($desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
do { $_V6_PAD{5964} = [ eval  {  code();
 }  ]; $::_V6_ERR_ = $@; @{$_V6_PAD{5964}} };
if($::_V6_ERR_) {  @_ = ([\(1, $desc, )], {todo => \($todo)});
 goto( Pugs::Runtime::Perl6::Routine->new(\&Test::ok)->code );
 } 
else  {  Test::proclaim([\( undef , $desc, $todo, "No exception thrown", )], {depends => \($depends)});
 } 
;

 };
## Signature for dies_ok
 Data::Bind->sub_signature
 (\&dies_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Code',  'var' => '&code'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'lives_ok'; sub lives_ok {
   my %_V6_PAD;
  my ($desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
do { $_V6_PAD{5965} = [ eval  {  code();
 }  ]; $::_V6_ERR_ = $@; @{$_V6_PAD{5965}} };
if($::_V6_ERR_) {  Test::proclaim([\( undef , $desc, $todo, "An exception was thrown : " . $::_V6_ERR_, )], {depends => \($depends)});
 } 
else  {  @_ = ([\(1, $desc, )], {todo => \($todo),depends => \($depends)});
 goto( Pugs::Runtime::Perl6::Routine->new(\&Test::ok)->code );
 } 
;

 };
## Signature for lives_ok
 Data::Bind->sub_signature
 (\&lives_ok, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Code',  'var' => '&code'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
 sub version_lt {
   my %_V6_PAD;
  my ($version1,$version2);
  Data::Bind->arg_bind(\@_);
  ;
my @num1 = (split('.',
$version1));
my @num2 = (split('.',
$version2));
Pugs::Runtime::Perl6::Array::map([\ Data::Bind->sub_signature( sub {   my %_V6_PAD;
  my ($a,$b);
  Data::Bind->arg_bind(\@_);
  ;
if($a == $b) {  next() } 
;
if($a < $b) { return( True()) } 
;
return( False());

 }, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$a'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '$b'})
, [do {  my $n = @num1 > @num2 ? @num1 : @num2;  map { ( $num1[$_], $num2[$_] ) } 0..$n-1}]], {});
return( False());

 };
## Signature for version_lt
 Data::Bind->sub_signature
 (\&version_lt, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$version1'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$version2'});
;
push @EXPORT, 'todo'; sub todo {
   my %_V6_PAD;
  my (%deadline);
  Data::Bind->arg_bind(\@_);
  ;
if((defined $::_V6_COMPILER_NAME)
 ? 0 : 1 ) { return() } 
;
my $spec_ver = ( $deadline{ lc($::_V6_COMPILER_NAME) } );
if((((defined $spec_ver)
 ? 0 : 1  or $spec_ver eq '1') or  Test::version_lt([\($::_V6_COMPILER_VERSION, $spec_ver, )], {}))) { $Test::todo_next_test =  True();
return( True());
 } 
;
return( False());

 };
## Signature for todo
 Data::Bind->sub_signature
 (\&todo, {  'attribute' => [],  'is_slurpy' => '*',  'named_only' => '',  'optional' => '',  'type' => undef,  'var' => '%deadline'});
;
push @EXPORT, 'skip'; sub skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5 {
   my %_V6_PAD;
  my ($reason,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Test::proclaim([\(1, "", "skip " . $reason, )], {depends => \($depends)});

 };
## Signature for skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5
 Data::Bind->sub_signature
 (\&skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$reason'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
BEGIN { Sub::Multi->add_multi('skip', \&skip_d2a40e26c9b0a8f3437dfcb39c0ad4e5) }
;
push @EXPORT, 'skip'; sub skip_63cca366074e191396ec328f2456877c {
   my %_V6_PAD;
  my ($count,$reason,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 for((1 .. $count)) { if($^O eq "browser") {  Test::proclaim([\(1, "", "skip " . $reason, )], {depends => \($depends)});
 } 
else  {  Test::skip([\($reason, )], {depends => \($depends)});
 } 
;
 } ;

 };
## Signature for skip_63cca366074e191396ec328f2456877c
 Data::Bind->sub_signature
 (\&skip_63cca366074e191396ec328f2456877c, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Int',  'var' => '$count'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$reason'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
BEGIN { Sub::Multi->add_multi('skip', \&skip_63cca366074e191396ec328f2456877c) }
;
push @EXPORT, 'skip_rest'; sub skip_rest {
   my %_V6_PAD;
  my ($reason,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Test::skip([\(($Test::num_of_tests_planned - $Test::num_of_tests_run),  ( !defined ( $_V6_PAD{5966} = ( $reason ))  ? ( "" )  : $_V6_PAD{5966} ) , )], {depends => \($depends)});

 };
## Signature for skip_rest
 Data::Bind->sub_signature
 (\&skip_rest, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$reason'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'pass'; sub pass {
   my %_V6_PAD;
  my ($desc);
  Data::Bind->arg_bind(\@_);
  ;
 Test::proclaim([\(1, $desc, )], {});

 };
## Signature for pass
 Data::Bind->sub_signature
 (\&pass, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'});
;
push @EXPORT, 'flunk'; sub flunk {
   my %_V6_PAD;
  my ($desc,$todo,$depends);
  Data::Bind->arg_bind(\@_);
  ;
 Test::proclaim([\(0, $desc, $todo, )], {depends => \($depends)});

 };
## Signature for flunk
 Data::Bind->sub_signature
 (\&flunk, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => ':',  'optional' => '',  'type' => undef,  'var' => '$depends'});
;
push @EXPORT, 'diag'; sub diag {
   my %_V6_PAD;
  my ($diag);
  Data::Bind->arg_bind(\@_);
  ;
for my $line(split("\n",
$diag)) { if($::_V6_MATCH_ = Pugs::Compiler::Regex->compile( q{Failed \(TODO.*?\) test} )->match($diag)) {  print '', $::_V6_STDOUT, "\n";
 } 
else  {  print STDERR '', ("# " . $line), "\n";
 } 
;
 };

 };
## Signature for diag
 Data::Bind->sub_signature
 (\&diag, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Str',  'var' => '$diag'});
;
 sub proclaim {
   my %_V6_PAD;
  my ($cond,$desc,$todo,$got,$expected,$depends,$negate);
  Data::Bind->arg_bind(\@_);
  ;
$Test::testing_started = 1;
$Test::num_of_tests_run++;
my $context;
if(index($Test::force_todo_test_junction,
' ' . $Test::num_of_tests_run . ' ') >= 0) { $context = "TODO for release" } 
;
if($Test::todo_next_test) { $context = "TODO" . (do { my @_V6_TMP = $todo; ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0]  ? $_V6_TMP[0]->isa('Str') :  Pugs::Runtime::Perl6::Scalar::isa( @_V6_TMP, ('Str')) ) } ? " " . $todo : '');
$Test::todo_next_test =  False();
 } 
elsif ($todo) { if(substr($todo,
0,
4) eq 'skip') { $context = $todo;
 } 
else  { $context = "TODO" . (do { my @_V6_TMP = $todo; ( @_V6_TMP == 1 && Scalar::Util::blessed $_V6_TMP[0]  ? $_V6_TMP[0]->isa('Str') :  Pugs::Runtime::Perl6::Scalar::isa( @_V6_TMP, ('Str')) ) } ? " " . $todo : '');
if($cond) { $Test::num_of_tests_badpass++;
 } 
;
 } 
;
 } 
;
if($depends) { $context .= " (depends on " . $depends . " working)";
 } 
;
my $out = ( (defined $desc)
 ? " - " . $desc : "" );
if($Test::ALWAYS_CALLER) { $out = $out . " <pos:" . join(' line ', (caller(1))[1,2]) . ">" } 
;
$out =~ s{#}{\\#}g;
my $context_out = ( (defined $context)
 ? " # " . $context : "" );
 ( print '', (($cond ? "ok " : "not ok "),
$Test::num_of_tests_run,
$out,
$context_out),"\n" ) ;
 unless($cond) {  Test::report_failure([\($context, $got, $expected, $negate, )], {}) } 
;
return($cond);

 };
## Signature for proclaim
 Data::Bind->sub_signature
 (\&proclaim, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '',  'type' => 'Bool',  'var' => '$cond'},
         {  'attribute' => [    [      {        'bareword' => 'is'      },      {        'bareword' => 'copy'      }    ]  ],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$desc'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => undef,  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => undef,  'var' => '$depends'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => undef,  'var' => '$negate'});
;
 sub report_failure {
   my %_V6_PAD;
  my ($todo,$got,$expected,$negate);
  Data::Bind->arg_bind(\@_);
  ;
if($todo) {  Test::diag([\("  Failed (" . $todo . ") test (" . join(' line ', (caller(2))[1,2]) . ")", )], {});
 } 
else  {  Test::diag([\("  Failed test (" . join(' line ', (caller(2))[1,2]) . ")", )], {});
$Test::num_of_tests_failed++;
 } 
;
my $wanted = ( $negate ? "Unwanted" : "Expected" );
if(index('&Test::is &Test::isnt &Test::cmp_ok &Test::isa_ok &Test::is_deeply &Test::todo_is &Test::todo_isnt &Test::todo_cmp_ok &Test::todo_eval_is &Test::todo_isa_ok ',
Pugs::Runtime::Perl6::Routine->new(Devel::Caller::caller_cv(2))->name() . ' ') >= 0) {  Test::diag([\("  " . $wanted . ": '" . ((defined $expected)
 ? $expected : "undef") . "'", )], {});
 Test::diag([\("    Actual: '" . ((defined $got)
 ? $got : "undef") . "'", )], {});
 } 
else  {  Test::diag([\("    Actual: " . ((defined $got)
 ? $got : "undef"), )], {});
 } 
;

 };
## Signature for report_failure
 Data::Bind->sub_signature
 (\&report_failure, {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$todo'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$got'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Str',  'var' => '$expected'},
         {  'attribute' => [],  'is_slurpy' => '',  'named_only' => '',  'optional' => '?',  'type' => 'Bool',  'var' => '$negate'});
;
 sub test_ends {
   my %_V6_PAD;
 unless($Test::testing_started) { return() } 
;
if( (defined ($Test::num_of_tests_planned) ) ? 0 : 1 ) {  ( print '', ("1.." . $Test::num_of_tests_run),"\n" ) ;
 } 
elsif ($Test::num_of_tests_planned != $Test::num_of_tests_run) {  print STDERR '', ("# Looks like you planned " . $Test::num_of_tests_planned . " tests, but ran " . $Test::num_of_tests_run), "\n";
 } 
;
if($Test::num_of_tests_failed) {  print STDERR '', ("# Looks like you failed " . $Test::num_of_tests_failed . " tests of " . $Test::num_of_tests_run), "\n";
 } 
;
if($Test::num_of_tests_badpass) {  print STDERR '', ("# Looks like " . $Test::num_of_tests_badpass . " tests of " . $Test::num_of_tests_run . " passed unexpectedly"), "\n";
 } 
;
$Test::num_of_tests_run = 0;
$Test::num_of_tests_failed = 0;
$Test::num_of_tests_badpass = 0;
$Test::num_of_tests_planned =  undef ;
$Test::force_todo_test_junction =  undef ;
$Test::testing_started = 0;

 };
## Signature for test_ends
 Data::Bind->sub_signature
 (\&test_ends, );
;
END {  Test::test_ends();
 } ;

; 1;
